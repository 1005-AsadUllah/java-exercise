# Understanding immutable collection in Java (Layman's Terms)

## ğŸ”¹ Link : <https://dev.java/learn/api/collections-framework/>

## 1. Creating Immutable Collections (Java 9+)

Think of `immutable collections` like a read-only list of itemsâ€”you canâ€™t `add`, `remove`, or `change elements once created`.

ğŸ”¹ **How to create them:**

```java

List<String> list = List.of("Apple", "Banana", "Cherry");
Set<String> set = Set.of("Apple", "Banana", "Cherry");
```

ğŸ”¹ **Key rules:**

- âœ… **Fast and memory-efficient** because Java optimizes them internally.
- âŒ **No null values allowed** (Set.of(null) will throw an error).
- âŒ **No duplicates allowed** in Set (Set.of("Apple", "Apple") will throw an error).

## 2. Copying a Collection (Java 10+)

Think of this as `taking a frozen snapshot` of an existing list or set. If the original changes, the copy `doesnâ€™t change`.

ğŸ”¹ **How to create a copy:**

```java

List<String> originalList = List.of("A", "B", "C");
List<String> copiedList = List.copyOf(originalList);
```

ğŸ”¹ **Key rules:**

- âœ… The new copy is `immutable` (cannot be changed).
- âœ… The original and the copy are `independent`.
- âŒ **No null values allowed**.
- âŒ **Set.copyOf() removes duplicates if found**.

## 3. Wrapping an Array in a List

Imagine you have an `array` of items and want to use it like a list. `Arrays.asList()` does that.

ğŸ”¹ **Example:**

```java

String[] fruits = {"Apple", "Banana", "Cherry"};
List<String> list = Arrays.asList(fruits);
```

ğŸ”¹ **Key rules:**

- âœ… **Fast conversion** from array to list.
- âŒ **Fixed size** (cannot add/remove elements, only replace them).

## 4. Using Collections Factory Methods to Process Data

ğŸ”¹ **Extracting Min/Max from a Collection**

Think of `min()` and `max()` as **finding the smallest and largest numbers in a list.**

```java

List<Integer> numbers = List.of(5, 3, 9, 1, 7);
int min = Collections.min(numbers);
int max = Collections.max(numbers);
System.out.println(min); // 1
System.out.println(max); // 9
```

âœ” Works on numbers, strings, and anything that is `Comparable`.

ğŸ”¹ **Finding a Sublist**
Finds a **smaller sequence inside a bigger list**.

```java

List<String> words = List.of("Java", "is", "a", "powerful", "language");
List<String> sublist = List.of("a", "powerful");

int firstIndex = Collections.indexOfSubList(words, sublist);
System.out.println(firstIndex); // 2
```

âœ” Helps in **pattern matching** inside lists.

ğŸ”¹ **Changing the Order of a List**

**sort()**: Sorts the list in place, accepts a `Comparator`.

**shuffle():** Randomly shuffles the list. Allows a custom `Random` instance.

**rotate()**: Rotates elements in the list.

### Example

```java
List<String> strings = Arrays.asList("0", "1", "2", "3", "4");
System.out.println(strings);
int fromIndex = 1, toIndex = 4;
Collections.rotate(strings.subList(fromIndex, toIndex), -1);
System.out.println(strings);
```

Output:

```xml
[0, 1, 2, 3, 4]
[0, 2, 3, 1, 4]
```

**reverse()**: **Reverses** the list order.

**swap()**: Swaps **two** elements in the list or array.

```java

List<String> letters = new ArrayList<>(List.of("A", "B", "C", "D"));

Collections.shuffle(letters);
Collections.reverse(letters);
Collections.swap(letters, 0, 2);
Collections.sort(letters);
```

âœ” Great for `randomizing`, `sorting`, or `reordering lists`.

## 5. Wrapping Collections for Safety

ğŸ”¹ Creating an **Immutable Wrapper** (Read-Only Mode)

```java

List<String> modifiableList = new ArrayList<>(List.of("A", "B", "C"));
List<String> unmodifiableList = Collections.unmodifiableList(modifiableList);
```

âœ” The original list is **still changeable**, but the **wrapper blocks direct modifications**.

ğŸ”¹ Creating a **Thread-Safe Collection**
If multiple **threads need to access a list**, make it **synchronized**:

```java

List<String> syncList = Collections.synchronizedList(new ArrayList<>());
```

âœ” Prevents **race conditions** but might **not be the best** option (better alternatives exist in `java.util.concurrent`).

## Final Takeaway

| Feature              | List.of() / Set.of()     | List.copyOf()            | Arrays.asList()    | unmodifiableList()             | synchronizedList()      |
| -------------------- | ------------------------ | ------------------------ | ------------------ | ------------------------------ | ----------------------- |
| Immutable?           | âœ… Yes                   | âœ… Yes                   | âŒ No (fixed size) | âœ… Yes                         | âŒ No (but thread-safe) |
| Accepts null?        | âŒ No                    | âŒ No                    | âœ… Yes             | âœ… Yes                         | âœ… Yes                  |
| Allows duplicates?   | âœ… Yes (List)âŒ No (Set) | âœ… Yes (List)âŒ No (Set) | âœ… Yes             | âœ… Yes                         | âœ… Yes                  |
| Thread-safe?         | âŒ No                    | âŒ No                    | âŒ No              | âŒ No                          | âœ… Yes                  |
| Can modify original? | âŒ No                    | âŒ No                    | âœ… Yes (limited)   | âœ… Yes (but wrapper is locked) | âœ… Yes                  |

- âœ” Use `List.of() / Set.of()` for simple **read-only lists**.
- âœ” Use `List.copyOf()` for creating a **frozen copy of another collection**.
- âœ” Use `Arrays.asList()` to **treat arrays like lists**.
- âœ” Use `unmodifiableList()` if you want **a wrapper but may still modify the original**.
- âœ” Use `synchronizedList()` when **multiple threads access the list**.
