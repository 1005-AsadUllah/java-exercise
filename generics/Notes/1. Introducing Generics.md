# ğŸš€ **Introducing Generics**

## ğŸ”¹ Reference : <https://dev.java/learn/generics/intro/>

## 1. â“ **Why Use Generics?**

Generics allow **types** (classes and interfaces) to be used as **parameters** when defining classes, interfaces, and methods. This enables **code reuse** with different data types.

### ğŸ¯ **Benefits of Generics**

âœ… **Stronger Type Checks at Compile Time**

- Ensures **type safety** and helps catch errors **early**.

âœ… **Elimination of Casts**

- **Without Generics (âŒ Casting Required)**

  ```java
  List list = new ArrayList();
  list.add("hello");
  String s = (String) list.get(0);
  ```

- **With Generics (âœ”ï¸ No Casting Needed)**

  ```java
  List<String> list = new ArrayList<String>();
  list.add("hello");
  String s = list.get(0);  // no cast
  ```

âœ… **Enabling Generic Algorithms**

- Allows creating **reusable** and **type-safe** algorithms for different data types.

---

## 2. ğŸ“¦ **Generic Types**

### ğŸ”¹ **A Simple Box Class**

A **generic type** is a class or interface that is **parameterized over types**. Below is a non-generic `Box` class:

```java
public class Box {
    private Object object;

    public void set(Object object) { this.object = object; }
    public Object get() { return object; }
}
```

âš ï¸ **Issue**: Since it uses `Object`, it lacks type safety. It allows storing any type, leading to potential runtime errors.

### ğŸ¯ **A Generic Version of the Box Class**

A **generic class** is defined as:

```java
class ClassName<T> { /* ... */ }
```

Updating the `Box` class to use generics:

```java
/**
 * Generic version of the Box class.
 * @param <T> the type of the value being boxed
 */
public class Box<T> {
    private T t;

    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
```

âœ… **Improvement**:

- `T` replaces `Object`, ensuring type safety.
- Works with **any** non-primitive type.

### ğŸ”  **Type Parameter Naming Conventions**

By convention, **single uppercase letters** are used:

- ğŸ”‘ `K` - Key
- ğŸ”¢ `N` - Number
- ğŸ”¤ `T` - Type
- ğŸ“¦ `V` - Value
- ğŸ“‹ `E` - Element (used in collections)

### ğŸ› ï¸ **Invoking and Instantiating a Generic Type**

To create a **generic object**, specify the type:

```java
Box<Integer> integerBox;
```

This declares `integerBox` as a **Box of Integer**.

ğŸ”¹ **Instantiation:**

```java
Box<Integer> integerBox = new Box<Integer>();
```

### ğŸ’ **The Diamond Operator (<>)**

Since **Java SE 7**, the type argument can be inferred:

```java
Box<Integer> integerBox = new Box<>();
```

âœ… **Shorter and cleaner syntax**.

### ğŸ”„ **Multiple Type Parameters**

A generic class **can have multiple type parameters**.

**Example:** A `Pair` interface and `OrderedPair` class:

```java
public interface Pair<K, V> {
    K getKey();
    V getValue();
}

public class OrderedPair<K, V> implements Pair<K, V> {
    private K key;
    private V value;

    public OrderedPair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public K getKey() { return key; }
    public V getValue() { return value; }
}
```

ğŸ”¹ **Usage:**

```java
Pair<String, Integer> p1 = new OrderedPair<>("Even", 8);
Pair<String, String>  p2 = new OrderedPair<>("hello", "world");
```

### ğŸ—ï¸ **Parameterized Types**

You can **nest parameterized types**:

```java
OrderedPair<String, Box<Integer>> p = new OrderedPair<>("primes", new Box<>());
```

This demonstrates the flexibility and **type safety** of generics in Java. ğŸ¯

## 3. ğŸ›‘ **Raw Types**

### ğŸ“Œ **What is a Raw Type?**

A **raw type** is a generic class or interface **without specifying a type argument**.

**Example:**

```java
public class Box<T> {
    public void set(T t) { /* ... */ }
}
```

âœ… **Parameterized Type (Correct Usage)**

```java
Box<Integer> intBox = new Box<>();
```

âš ï¸ **Raw Type (Avoid This)**

```java
Box rawBox = new Box();  // No type argument
```

Here, `Box` is a **raw type** of `Box<T>`, meaning it behaves as if **generics were never used**.

---

### ğŸ› **Why Do Raw Types Exist?**

Raw types exist **for backward compatibility** with **pre-JDK 5.0** code, where generics didnâ€™t exist.

ğŸ“Œ **Example of Legacy Code Compatibility:**

```java
Box<String> stringBox = new Box<>();
Box rawBox = stringBox;  // âœ… Allowed (but not recommended)
```

ğŸ“Œ **But if assigned back to a generic type:**

```java
Box rawBox = new Box();
Box<Integer> intBox = rawBox;  // âš ï¸ Warning: unchecked conversion
```

---

### âš ï¸ **Dangers of Using Raw Types**

1ï¸âƒ£ **Bypasses Type Safety:** Allows storing incompatible types, leading to runtime errors.  
2ï¸âƒ£ **Unchecked Warnings:** Compiler **cannot check type correctness**.  
3ï¸âƒ£ **Invoking Generic Methods Gives Warnings:**

```java
Box<String> stringBox = new Box<>();
Box rawBox = stringBox;
rawBox.set(8);  // âš ï¸ Warning: unchecked invocation to set(T)
```

ğŸ“Œ **Key Takeaway:** Avoid using **raw types** in modern Java. Use **parameterized types** instead.

---

### ğŸ“ **Unchecked Error Messages & Solutions**

When using **legacy APIs** that operate on **raw types**, Java may show warnings:

```xml
Note: Example.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
```

ğŸ“Œ **Example of Unchecked Warning:**

```java
public class WarningDemo {
    public static void main(String[] args){
        Box<Integer> bi;
        bi = createBox();
    }

    static Box createBox(){
        return new Box();  // âš ï¸ Warning: unchecked conversion
    }
}
```

ğŸ’¡ **Solution:** Recompile with `-Xlint:unchecked` to see details:

```xml
WarningDemo.java:4: warning: [unchecked] unchecked conversion
found   : Box
required: Box<java.lang.Integer>
```

---

### âœ… **How to Suppress Unchecked Warnings?**

âœ”ï¸ Use `@SuppressWarnings("unchecked")`:

```java
@SuppressWarnings("unchecked")
static Box createBox() {
    return new Box();  // No warning shown
}
```

âœ”ï¸ Disable warnings with `-Xlint:-unchecked` (Not recommended).

ğŸš€ **Best Practice:** **Always use parameterized types** to ensure **type safety** and cleaner code.

## 4. âœ¨ **Generic Methods**

### ğŸ”¹ **What are Generic Methods?**

A **generic method** introduces its own type parameters, similar to a generic class, but the type scope is **limited to the method** itself.

ğŸ“Œ **Key Features:**  
âœ… Works with **static & non-static** methods  
âœ… **Defined before** return type  
âœ… Can be used in **constructors**

---

### ğŸ“ **Syntax of a Generic Method**

A generic method has **type parameters (inside `<>`) before the return type**:

```java
public class Util {
    public static <K, V> boolean compare(Pair<K, V> p1, Pair<K, V> p2) {
        return p1.getKey().equals(p2.getKey()) &&
               p1.getValue().equals(p2.getValue());
    }
}
```

---

### ğŸ¯ **Example: Using Generic Methods**

Let's define a generic `Pair<K, V>` class and use the `compare()` method:

```java
public class Pair<K, V> {
    private K key;
    private V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public K getKey() { return key; }
    public V getValue() { return value; }
}
```

ğŸ“Œ **Invoking the Generic Method**

```java
Pair<Integer, String> p1 = new Pair<>(1, "apple");
Pair<Integer, String> p2 = new Pair<>(2, "pear");

// Explicit type invocation
boolean same = Util.<Integer, String>compare(p1, p2);

// Type inference (compiler automatically detects types)
boolean same2 = Util.compare(p1, p2);
```

ğŸ’¡ **Type Inference:** You usually **donâ€™t need** to specify `<Integer, String>` explicitly!

---

## 5. ğŸ“Œ **Bounded Type Parameters**

### â“ **Why Use Bounded Type Parameters?**

Sometimes, we want **only specific types** to be allowed.  
For example, a method working with numbers **should not** accept Strings.

### ğŸ“ **Declaring a Bounded Type Parameter**

Use `extends` to **restrict** the allowed types:

```java
public class Box<T> {
    private T t;

    public void set(T t) { this.t = t; }
    public T get() { return t; }

    // Generic method with a bounded type parameter
    public <U extends Number> void inspect(U u) {
        System.out.println("T: " + t.getClass().getName());
        System.out.println("U: " + u.getClass().getName());
    }
}
```

ğŸ“Œ **Using the Bounded Generic Method**

```java
Box<Integer> integerBox = new Box<>();
integerBox.set(10);

// Valid: Integer is a subclass of Number
integerBox.inspect(5.5);

// âŒ Error: "String" is NOT a subclass of "Number"
integerBox.inspect("text");  // Compilation error!
```

ğŸš€ **Benefit:** Prevents incorrect types at compile time.

---

### ğŸ”¹ **Multiple Bounds in Generics**

A generic type can **extend multiple types** using `&`.

```java
class A { /* ... */ }
interface B { /* ... */ }
interface C { /* ... */ }

class D<T extends A & B & C> { /* ... */ }
```

âš ï¸ **Rules:**  
âœ… If one of the bounds is a **class**, it must come **first**  
âŒ `class D<T extends B & A & C> {}` **(Error: class A should be first)**

ğŸ“Œ **Example: Using Multiple Bounds**

```java
class Animal { /* Base class */ }
interface CanRun { void run(); }
interface CanSwim { void swim(); }

class Amphibian<T extends Animal & CanRun & CanSwim> {
    private T creature;

    public Amphibian(T creature) { this.creature = creature; }

    public void move() {
        creature.run();
        creature.swim();
    }
}
```

ğŸ’¡ **Benefit:** This ensures `T` is always an `Animal` **AND** can run/swim.

---

## âœ… **Key Takeaways**

âœ”ï¸ **Generic methods** allow flexible, reusable methods with type safety  
âœ”ï¸ **Type inference** helps avoid unnecessary type declarations  
âœ”ï¸ **Bounded types (`<T extends SomeType>`)** restrict allowed types  
âœ”ï¸ **Multiple bounds** (`T extends Class & Interface`) allow complex constraints

ğŸš€ **Use generics to write cleaner, safer, and more reusable code!**

---

## 6.ğŸ”¥ **Generic Methods and Bounded Type Parameters**

### ğŸ“Œ **Why Use Bounded Type Parameters?**

Bounded type parameters **help implement generic algorithms** that work with a restricted set of types.

ğŸ’¡ **Example:** Counting elements **greater than** a given element in an array.

---

### âŒ **Issue with Unbounded Generics**

```java
public static <T> int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e > elem)  // âŒ Compiler Error!
            ++count;
    return count;
}
```

ğŸš¨ **Error:** The `>` operator **only works for primitive types** (`int`, `double`, etc.), **not objects**.

---

### âœ… **Solution: Use `Comparable<T>` Interface**

To compare objects, we use `Comparable<T>`, which provides the `compareTo()` method.

#### **ğŸ“ `Comparable<T>` Interface**

```java
public interface Comparable<T> {
    int compareTo(T o);
}
```

### **âœ”ï¸ Fixed Code: Using a Bounded Type Parameter**

```java
public static <T extends Comparable<T>> int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e.compareTo(elem) > 0)  // âœ… Now it's valid
            ++count;
    return count;
}
```

---

### ğŸ¯ **Example Usage**

```java
public class Main {
    public static void main(String[] args) {
        Integer[] numbers = {1, 5, 10, 20, 30};
        System.out.println(countGreaterThan(numbers, 10)); // Output: 2

        String[] words = {"apple", "banana", "cherry"};
        System.out.println(countGreaterThan(words, "banana")); // Output: 1
    }
}
```

---

### ğŸš€ **Key Takeaways**

âœ”ï¸ **Bounded types** allow generics to work with comparable objects  
âœ”ï¸ **`T extends Comparable<T>`** ensures that `T` can be compared  
âœ”ï¸ **Use `compareTo()`** instead of comparison operators (`>`, `<`) for objects

âœ… **Now, our method works for `Integer`, `String`, and any `Comparable<T>` type!**

---

## 6. ğŸ¯ **Generics, Inheritance, and Subtypes**

### ğŸ” **Understanding Subtyping in Java**

In Java, **subtyping** allows an object of a subclass to be assigned to a variable of its superclass. This follows the **"is-a"** relationship:

```java
Object someObject = new Object();
Integer someInteger = new Integer(10);
someObject = someInteger;  // âœ… Integer "is a" kind of Object
```

Since **Integer extends Number**, it can also be used where a `Number` is expected:

```java
public void someMethod(Number n) { /* ... */ }

someMethod(new Integer(10));   // âœ… OK
someMethod(new Double(10.1));  // âœ… OK
```

---

### ğŸ”¥ **Subtyping and Generics**

With generics, we can define a class that accepts a **type parameter**, like `Box<T>`:

```java
Box<Number> box = new Box<>();
box.add(new Integer(10));   // âœ… OK
box.add(new Double(10.1));  // âœ… OK
```

Here, `Box<Number>` can hold any subclass of `Number` (`Integer`, `Double`, etc.).

---

### âŒ **Common Mistake: Generics Donâ€™t Inherit Like Normal Types**

Consider this method:

```java
public void boxTest(Box<Number> n) { /* ... */ }
```

You might think you can pass `Box<Integer>` or `Box<Double>`, but **this is incorrect!**

```java
Box<Integer> intBox = new Box<>();
boxTest(intBox);  // âŒ ERROR: Box<Integer> is NOT a subtype of Box<Number>
```

### âš  **Why?**

- `Integer` **is a** `Number`, but `Box<Integer>` **is NOT a** `Box<Number>`.
- `Box<Number>` and `Box<Integer>` **are completely separate types**.

**ğŸš€ Key Rule:**  
`Box<A>` **and** `Box<B>` **are unrelated**, even if `A` is a subtype of `B`.  
ğŸ‘‰ **The common parent is `Object`**, not `Box<B>`.

---

### âœ… **Solution: Using Wildcards (`? extends` & `? super`)**

### ğŸ”¹ **Wildcard for Subtypes (`? extends T`)**

To allow **Box<Integer>** and **Box<Double>**, use a **bounded wildcard**:

```java
public void boxTest(Box<? extends Number> n) { /* ... */ }
```

Now you can pass **any Box of a subclass of `Number`**:

```java
Box<Integer> intBox = new Box<>();
Box<Double> doubleBox = new Box<>();
boxTest(intBox);  // âœ… OK
boxTest(doubleBox); // âœ… OK
```

### ğŸ”¹ **Wildcard for Supertypes (`? super T`)**

If we want to accept a `Box` that **can store a Number or its superclasses**, use `? super Number`:

```java
public void addNumber(Box<? super Number> box) {
    box.add(new Integer(10));  // âœ… Allowed
    box.add(new Double(10.5)); // âœ… Allowed
}
```

---

### ğŸ“š **Generic Classes and Subtyping**

You **can inherit from a generic class**. The subtype relationship follows **if the type parameter stays the same**.

ğŸ”¹ **Example with Java Collections:**

```java
ArrayList<String> list = new ArrayList<>();
List<String> strList = list;  // âœ… OK (ArrayList<String> is a List<String>)
Collection<String> collection = list; // âœ… OK (List<String> is a Collection<String>)
```

âœ” **`ArrayList<String>` is a subtype of `List<String>`**, which is a subtype of `Collection<String>`.

---

### ğŸ”¥ **Creating Your Own Subtyped Generic Class**

Let's say we define a `PayloadList` that extends `List<E>` and has a second type `P` for **extra payload data**:

```java
interface PayloadList<E, P> extends List<E> {
    void setPayload(int index, P val);
}
```

Different parameterizations of `PayloadList` **are subtypes of `List<String>`**:
âœ” `PayloadList<String, String>`  
âœ” `PayloadList<String, Integer>`  
âœ” `PayloadList<String, Exception>`

---

### ğŸš€ **Key Takeaways**

âœ… **Generics don't follow normal inheritance rules** (`Box<Integer>` â‰  `Box<Number>`)  
âœ… **Use wildcards (`? extends T` and `? super T`) to allow flexible subtyping**  
âœ… **Subtyping works when type parameters remain the same (e.g., `List<String>` âŠ‚ `Collection<String>`)**

**ğŸ’¡ Now you know how generics and inheritance work together!** ğŸš€
