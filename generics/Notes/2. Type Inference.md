# ğŸš€ **Type Inference**

## ğŸ” **Type Inference & Generic Methods**

### ğŸ“Œ **What is Type Inference?**

- Type inference allows the Java compiler to determine type arguments automatically.
- The inference algorithm:  
  âœ… Determines argument types.  
  âœ… Considers the type of the assigned/returned result.  
  âœ… Finds the most specific type that fits all arguments.

### ğŸ— **Example of Type Inference**

```java
static <T> T pick(T a1, T a2) { return a2; }
Serializable s = pick("d", new ArrayList<String>());
```

ğŸ”¹ Here, the second argument is inferred as `Serializable`.

### ğŸš€ **Type Inference in Generic Methods**

- Allows invoking generic methods without explicitly specifying a type.
- Example from `BoxDemo`:

  ```java
  public static <U> void addBox(U u, List<Box<U>> boxes) {
      Box<U> box = new Box<>();
      box.set(u);
      boxes.add(box);
  }
  ```

  ğŸ”¹ Java compiler infers `U` automatically.

### ğŸ¯ **Calling Generic Methods**

âœ… With explicit type witness:

```java
BoxDemo.<Integer>addBox(Integer.valueOf(10), listOfIntegerBoxes);
```

âœ… Without explicit type witness (compiler infers `Integer`):

```java
BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);
```

### ğŸ“Œ **Example Output**

```java
Box #0 contains [10]
Box #1 contains [20]
Box #2 contains [30]
```

### ğŸ”¥ **Conclusion**

Type inference simplifies method calls by reducing the need for explicit type parameters, making Java code more concise and readable. ğŸš€

## ğŸ” **Instantiation of Generic Classes**

### ğŸ“Œ **What is the Diamond Operator?**

- The **diamond (`<>`)** allows the compiler to infer type arguments automatically when instantiating generic classes.
- Eliminates the need to specify type parameters explicitly.

### ğŸ— **Example: Instantiating Generic Classes Without the Diamond**

```java
Map<String, List<String>> myMap = new HashMap<String, List<String>>();
```

ğŸ”¹ Here, type arguments are explicitly provided on both sides.

### ğŸš€ **Using the Diamond Operator (`<>`)**

```java
Map<String, List<String>> myMap = new HashMap<>();
```

ğŸ”¹ The compiler infers `<String, List<String>>` automatically.

### âš ï¸ **Unchecked Conversion Warning (Without `<>`)**

```java
Map<String, List<String>> myMap = new HashMap(); // Warning âš ï¸
```

âŒ This causes a warning because `HashMap()` defaults to a raw type (`HashMap` instead of `HashMap<String, List<String>>`).

### ğŸ”¥ **Conclusion**

- The **diamond operator (`<>`)** improves readability and avoids redundant type declarations.
- Always use `<>` to avoid **unchecked conversion warnings**. ğŸš€

## ğŸ” **Generic Constructors in Generic & Non-Generic Classes**

### ğŸ“Œ **What are Generic Constructors?**

- **Constructors** can have their own **formal type parameters**, separate from the class type parameters.
- Generic constructors work in both **generic** and **non-generic** classes.

### ğŸ— **Example: Generic Constructor in a Generic Class**

```java
class MyClass<X> {
  <T> MyClass(T t) {
    // Constructor logic...
  }
}
```

ğŸ”¹ Here, `MyClass` is generic with type parameter `<X>`, and the constructor has its own type parameter `<T>`.

### ğŸš€ **Instantiating a Generic Class with a Generic Constructor**

```java
new MyClass<Integer>("");
```

ğŸ”¹ The compiler infers:  
âœ… `X = Integer` (from `MyClass<Integer>`)  
âœ… `T = String` (from `""` argument in the constructor)

### ğŸ¯ **Type Inference in Java SE 7+ with the Diamond (`<>`)**

```java
MyClass<Integer> myObject = new MyClass<>("");
```

ğŸ”¹ Here, the compiler infers:  
âœ… `X = Integer` (from `MyClass<Integer>`)  
âœ… `T = String` (from `""` argument)

### âš ï¸ **Key Note on Type Inference Algorithm**

- The inference algorithm **only** uses:  
  âœ… **Invocation arguments**  
  âœ… **Target types**  
  âœ… **Obvious expected return types**
- It **does not** use information from later in the program.

### ğŸ”¥ **Conclusion**

- Generic constructors allow flexibility in defining parameterized objects.
- Java SE 7+ supports **diamond (`<>`)** inference, reducing redundancy.
- Understanding type inference in constructors ensures **cleaner, more efficient code**. ğŸš€

## ğŸ” **Target Types**

### ğŸ“Œ **What is Target Typing?**

- **Target typing** allows the Java compiler to infer the type parameters of a generic method invocation based on the context in which it is used.
- The **target type** is the expected data type where the expression is used, such as the variable type or method argument.

### ğŸ— **Example: Using Target Types with `Collections.emptyList()`**

```java
static <T> List<T> emptyList();
```

### ğŸš€ **Example 1: Target Type Inference**

```java
List<String> listOne = Collections.emptyList();
```

ğŸ”¹ The target type is `List<String>`.  
ğŸ”¹ The compiler infers that `T` must be `String` because the method returns `List<T>`, and the assignment expects `List<String>`.

### ğŸ”¹ **Alternative with Type Witness**

```java
List<String> listOne = Collections.<String>emptyList();
```

âŒ This is not necessary because the compiler already infers `T` from the target type in this context.

### âš ï¸ **Issue in Java SE 7: Without Target Type Inference**

```java
void processStringList(List<String> stringList) {
    // process stringList
}
processStringList(Collections.emptyList());
```

âŒ **Error in Java SE 7**:  
The compiler tries to infer the type argument as `Object`, so `Collections.emptyList()` returns `List<Object>`, which cannot be assigned to `List<String>`.

### ğŸ”¹ **Workaround in Java SE 7**

```java
processStringList(Collections.<String>emptyList());
```

ğŸ”¹ **This works** because the type `String` is explicitly specified for `T`.

### ğŸš€ **Improvement in Java SE 8: Expanded Target Type Inference**

In **Java SE 8**, the compiler uses **method arguments** as part of target typing.  
So the following code **compiles successfully** in Java SE 8:

```java
processStringList(Collections.emptyList());
```

ğŸ”¹ The compiler infers `T = String` based on the target type of `processStringList()`, which expects `List<String>`.

### ğŸ”¥ **Conclusion**

- Target typing allows the Java compiler to infer the correct type parameters based on the context.
- **Java SE 8** improves target typing, eliminating the need for explicit type witnesses in many cases.
- Use **target typing** to simplify and enhance code readability. ğŸš€

## ğŸ” **Target Typing in Lambda Expressions**

### ğŸ“Œ **What is Target Typing in Lambda Expressions?**

- In **lambda expressions**, the Java compiler determines the type of the lambda based on the **target type** expected by the context in which the lambda is used.
- The **target type** refers to the expected type in the context, such as the method parameter type.

### ğŸ— **Example Methods with Lambda Expressions**

```java
public static void printPersons(List<Person> roster, CheckPerson tester) {
    // method body
}

public void printPersonsWithPredicate(List<Person> roster, Predicate<Person> tester) {
    // method body
}
```

#### ğŸš€ **Using Lambda Expressions with These Methods**

```java
printPersons(
    people,
    p -> p.getGender() == Person.Sex.MALE
         && p.getAge() >= 18
         && p.getAge() <= 25);
```

```java
printPersonsWithPredicate(
    people,
    p -> p.getGender() == Person.Sex.MALE
         && p.getAge() >= 18
         && p.getAge() <= 25);
```

### ğŸ¯ **How the Target Type Determines the Lambda Type**

- **In the first method**, `printPersons()`, the expected parameter type for `tester` is `CheckPerson`, so the lambda expression is treated as a `CheckPerson`.
- **In the second method**, `printPersonsWithPredicate()`, the expected parameter type is `Predicate<Person>`, so the lambda is treated as a `Predicate<Person>`.

### ğŸ”¹ **Target Type Inference Process**

When the Java compiler encounters a lambda expression, it checks the **target type** in the context:

- The target type for `printPersons()` is `CheckPerson`.
- The target type for `printPersonsWithPredicate()` is `Predicate<Person>`.

The compiler then infers the appropriate type for the lambda expression based on the method signature.

### ğŸš€ **Where Can You Use Lambda Expressions?**

You can use lambda expressions in any context where the **target type** can be inferred. These contexts include:

- **Variable declarations**
- **Assignments**
- **Return statements**
- **Array initializers**
- **Method or constructor arguments**
- **Lambda expression bodies**
- **Conditional expressions (?:)**
- **Cast expressions**

### ğŸ”¥ **Conclusion**

- The **target type** defines how a lambda expression is interpreted.
- The Java compiler uses the target type to infer the type of the lambda expression based on where it is used.
- Lambda expressions allow concise code when the target type is clear, making Java code more expressive and readable. ğŸš€

## ğŸ” **Target Types and Method Arguments**

### ğŸ“Œ **Understanding Target Types in Method Arguments**

In the context of method arguments, the **target type** is determined by:

1. **Overload resolution**
2. **Type argument inference**

### ğŸ— **Example: Runnable vs. Callable**

Consider the following two functional interfaces:

```java
public interface Runnable {
    void run(); // does not return a value
}

public interface Callable<V> {
    V call(); // returns a value of type V
}
```

#### ğŸš€ **Overloaded Method Example**

```java
void invoke(Runnable r) {
    r.run();
}

<T> T invoke(Callable<T> c) {
    return c.call();
}
```

### ğŸ¯ **Which Method Will Be Invoked?**

Suppose you have the following statement:

```java
String s = invoke(() -> "done");
```

- The **lambda expression** `() -> "done"` is interpreted as a **Callable<String>** because it returns a value (`"done"` of type `String`).
- Therefore, the method `invoke(Callable<T>)` will be invoked because it is the one that handles returning a value.

### ğŸ“Œ **Explanation:**

- **`invoke(Runnable r)`**: This method does not return a value, so it cannot handle lambda expressions that return a value.
- **`invoke(Callable<T> c)`**: This method **returns a value**, and the lambda expression `() -> "done"` matches the expected return type (`String` in this case).

### ğŸš€ **Conclusion**

- The **target type** for the lambda expression determines which overloaded method is invoked.
- In the example above, the lambda expression is a **Callable**, and the **invoke(Callable<T>)** method is selected because it returns a value.
- Understanding overload resolution and type argument inference is crucial when working with method arguments and lambdas.
