# ğŸ”’ Restrictions on Generics in Java

## 1. âŒ Cannot Instantiate Generic Types with Primitive Types

```java
Pair<int, char> p = new Pair<>(8, 'a'); // âŒ Compile-time error
Pair<Integer, Character> p = new Pair<>(8, 'a'); // âœ… Autoboxing handles this
```

âœ… **Why?** Generics work with objects, and primitive types like `int`, `char` aren't objects. Use wrapper classes (`Integer`, `Character`) instead.

---

## 2. âŒ Cannot Create Instances of Type Parameters

```java
public static <E> void append(List<E> list) {
    E elem = new E(); // âŒ Compile-time error
}
```

âœ… **Workaround**: Use reflection if you pass in the `Class<E>`:

```java
E elem = cls.newInstance(); // âœ…
```

ğŸ” **Why?** Type erasure removes the actual type at runtime, so the JVM doesn't know what `E` is.

---

## 3. âŒ Cannot Declare Static Fields with Type Parameters

```java
public class MobileDevice<T> {
    private static T os; // âŒ Compile-time error
}
```

âœ… **Why?** `static` members are shared across all instances, but `T` can differ between instances. This leads to ambiguity.

---

## 4. âŒ Cannot Use `instanceof` or Casts with Parameterized Types

```java
if (list instanceof ArrayList<Integer>) { } // âŒ Compile-time error
```

âœ… Use unbounded wildcards:

```java
if (list instanceof ArrayList<?>) { } // âœ…
```

ğŸ” **Why?** Type information is erased at runtime, so the JVM cannot distinguish between `ArrayList<Integer>` and `ArrayList<String>`.

---

## 5. âŒ Cannot Create Arrays of Parameterized Types

```java
List<Integer>[] array = new List<Integer>[10]; // âŒ Compile-time error
```

âœ… **Why?** Arrays are reifiable (know their type at runtime), but generics are not. This leads to type-safety issues.

---

## 6. âŒ Cannot Create, Catch, or Throw Objects of Parameterized Types

```java
class MathException<T> extends Exception {} // âŒ

public <T extends Exception> void doSomething() {
    try {
        // ...
    } catch (T e) { } // âŒ
}
```

âœ… But you _can_ throw a type parameter:

```java
class Parser<T extends Exception> {
    public void parse() throws T { } // âœ…
}
```

ğŸ” **Why?** Throwable must be reifiable, but type parameters are erased.

---

## 7. âŒ Cannot Overload Methods That Erase to the Same Raw Type

```java
public void print(Set<String> s) {}
public void print(Set<Integer> i) {} // âŒ Both erase to Set
```

âœ… **Why?** After type erasure, both become `print(Set)` â€” leading to a method signature clash.

---
